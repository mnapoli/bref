#!/usr/bin/env php
<?php
declare(strict_types=1);

use Bref\Console\Command\Local;
use Bref\Console\LoadingAnimation;
use Bref\Console\OpenUrl;
use Bref\Lambda\InvocationFailed;
use Bref\Lambda\SimpleLambdaClient;
use Symfony\Component\Console\Style\SymfonyStyle;
use Symfony\Component\Filesystem\Filesystem;
use Symfony\Component\Process\ExecutableFinder;
use Symfony\Component\Process\Process;
use Symfony\Component\Yaml\Yaml;

if (file_exists(__DIR__ . '/vendor/autoload.php')) {
    require_once __DIR__ . '/vendor/autoload.php';
} elseif (file_exists(__DIR__ . '/../autoload.php')) {
    /** @noinspection PhpIncludeInspection */
    require_once __DIR__ . '/../autoload.php';
} else {
    /** @noinspection PhpIncludeInspection */
    require_once __DIR__ . '/../../autoload.php';
}

function getServerlessInfo($stage, $profile, $io): array
{
    $command = ['serverless', 'info', '--aws-profile', $profile];

    if ($stage) {
        $command += ['--stage', $stage];
    }

    // serverless print deprecation message on stdout instead of stderr. We need to disable it to parse the outpout
    $serverlessInfo = new Symfony\Component\Process\Process(
        $command,
        null,
        ['SLS_DEPRECATION_DISABLE'=>"*"]
    );
    $serverlessInfo->start();
    $animation = new LoadingAnimation($io);
    do {
        $animation->tick('Retrieving the stack');
        usleep(100 * 1000);
    } while ($serverlessInfo->isRunning());
    $animation->clear();

    if (!$serverlessInfo->isSuccessful()) {
        throw new Exception("'The command `serverless info` failed' ".PHP_EOL.$serverlessInfo->getOutput());
    }

    $serverlessInfoOutput = Yaml::parse( substr($serverlessInfo->getOutput(), strpos($serverlessInfo->getOutput(), "\n") + 1));

    return ($serverlessInfoOutput);
}

function getFunctionWithConsoleLayer(): string
{
    if (!file_exists(__DIR__ . '/../../serverless.yml')) {
        throw new Exception('serverless.yml not found');
    }

    $serverlessInfoOutput = Yaml::parse(file_get_contents(__DIR__ . '/../../serverless.yml'));
    $nominatedFunctions = [];
    foreach ($serverlessInfoOutput['functions'] as $functionName => $function) {
        foreach ($function['layers'] as $layer) {
            if (strpos($layer, 'layer.console') !==FALSE) {
                $nominatedFunctions[] = $functionName;
            }
        }
    }

    if (sizeof($nominatedFunctions) == 0) {
        throw new Exception('Layer console is missing');
    }
    if (sizeof($nominatedFunctions) > 1) {
        throw new Exception('More than one function has the console layer. You can\'t use the default behavior');
    }

    return (reset($nominatedFunctions));
}

$app = new Silly\Application('Deploy serverless PHP applications');

$app->command('init', function (SymfonyStyle $io) {
    $exeFinder = new ExecutableFinder();
    if (! $exeFinder->find('serverless')) {
        $io->error(
            'The `serverless` command is not installed.' . PHP_EOL .
            'Please follow the instructions at https://bref.sh/docs/installation.html'
        );

        return 1;
    }

    if (file_exists('serverless.yml') || file_exists('index.php')) {
        $io->error('The directory already contains a `serverless.yml` and/or `index.php` file.');

        return 1;
    }

    $choice = $io->choice(
        'What kind of lambda do you want to create? (you will be able to add more functions later by editing `serverless.yml`)',
        [
            'Web application',
            'Event-driven function',
        ],
        'Web application',
    );
    $templateDirectory = [
        'Web application' => 'http',
        'Event-driven function' => 'function',
    ][$choice];

    $fs = new Filesystem;
    $rootPath = __DIR__ . "/template/$templateDirectory";

    $io->writeln("Creating index.php");
    $fs->copy("$rootPath/index.php", 'index.php');

    $io->writeln("Creating serverless.yml");

    $template = file_get_contents("$rootPath/serverless.yml");

    $template = str_replace('PHP_VERSION', PHP_MAJOR_VERSION . PHP_MINOR_VERSION, $template);

    file_put_contents('serverless.yml', $template);

    $filesToGitAdd = ['index.php', 'serverless.yml'];

    /*
     * We check if this is a git repository to automatically add files to git.
     */
    if ((new Process(['git', 'rev-parse', '--is-inside-work-tree']))->run() === 0) {
        foreach ($filesToGitAdd as $file) {
            (new Process(['git', 'add', $file]))->run();
        }
        $io->success([
            'Project initialized and ready to test or deploy.',
            'The files created were automatically added to git.',
        ]);
    } else {
        $io->success('Project initialized and ready to test or deploy.');
    }

    return 0;
});

/**
 * Run a CLI command in the remote environment.
 */
$app->command('cli [function] [--profile=] [--stage=] [arguments]*', function (?string $function, ?string $profile, ?string $stage, array $arguments, SymfonyStyle $io) {

    try {
        if (!$function) {
            $function= getFunctionWithConsoleLayer();
        }
    } catch (Exception $e) {
        $io->error($e->getMessage());
        return 1;
    }


    $profile = $profile ?: getenv('AWS_PROFILE') ?: 'default';
    $serverlessInfo =getServerlessInfo($stage, $profile, $io);

    $lambda = new SimpleLambdaClient(
        $serverlessInfo['region'],
        $profile,
        15 * 60 // maximum duration on Lambda
    );

    // Replace short function name (like in serverless.yml) by full qualified name
    if (array_key_exists($function, $serverlessInfo['functions'])){
        $function = $serverlessInfo['functions'][$function];
    }
    // Because arguments may contain spaces, and are going to be executed remotely
    // as a separate process, we need to escape all arguments.
    $arguments = array_map(static function (string $arg): string {
        return escapeshellarg($arg);
    }, $arguments);

    try {
        $result = $lambda->invoke($function, json_encode(implode(' ', $arguments)));
    } catch (InvocationFailed $e) {
        $io->getErrorStyle()->writeln('<info>' . $e->getInvocationLogs() . '</info>');
        $io->error($e->getMessage());
        return 1;
    }

    $payload = $result->getPayload();
    if (isset($payload['output'])) {
        $io->writeln($payload['output']);
    } else {
        $io->error('The command did not return a valid response.');
        $io->writeln('<info>Logs:</info>');
        $io->write('<comment>' . $result->getLogs() . '</comment>');
        $io->writeln('<info>Lambda result payload:</info>');
        $io->writeln(json_encode($payload, JSON_PRETTY_PRINT));
        return 1;
    }

    return (int) ($payload['exitCode'] ?? 1);
});

/**
 * Invoke a function locally
 */
$app->command(Local::SIGNATURE, new Local);

$app->command('dashboard [--host=] [--port=] [--profile=] [--stage=]', function (SymfonyStyle $io, string $host = 'localhost', int $port = 8000, string $profile = null, string $stage = null) {
    $io->info('The Bref Dashboard is also available as an application: https://dashboard.bref.sh');
    if ($host === 'localhost') {
        $host = '127.0.0.1';
    }
    if ($profile === null) {
        $profile = getenv('AWS_PROFILE') ?: 'default';
    }

    if (! file_exists('serverless.yml')) {
        $io->error('No `serverless.yml` file found.');

        return 1;
    }

    $exeFinder = new ExecutableFinder();
    if (! $exeFinder->find('docker')) {
        $io->error(
            'The `docker` command is not installed.' . PHP_EOL .
            'Please follow the instructions at https://docs.docker.com/install/'
        );

        return 1;
    }

    if (! $exeFinder->find('serverless')) {
        $io->error(
            'The `serverless` command is not installed.' . PHP_EOL .
            'Please follow the instructions at https://bref.sh/docs/installation.html'
        );

        return 1;
    }

    try {
        $serverlessInfo = getServerlessInfo($stage, $profile, $io);
    }catch (\Exception $e) {
        $io->error($e->getMessage());

        return 1;
    }

    $region = $serverlessInfo['region'];
    $stack = $serverlessInfo['stack'];

    $io->writeln("Stack: <fg=yellow>$stack ($region)</>");

    $dockerPull = new Process(['docker', 'pull', 'bref/dashboard']);
    $dockerPull->setTimeout(null);
    $dockerPull->start();

    $animation = new LoadingAnimation($io);

    do {
        $animation->tick('Retrieving the latest version of the dashboard');
        usleep(100*1000);
    } while ($dockerPull->isRunning());
    $animation->clear();
    if (! $dockerPull->isSuccessful()) {
        $io->error([
            'The command `docker pull bref/dashboard` failed',
            $dockerPull->getErrorOutput(),
        ]);

        return 1;
    }

    $process = new Process(['docker', 'run', '--rm', '-p', $host . ':' . $port.':8000', '-v', getenv('HOME').'/.aws:/root/.aws:ro', '--env', 'STACKNAME='.$stack, '--env', 'REGION='.$region, '--env', 'AWS_PROFILE='.$profile, 'bref/dashboard']);
    $process->setTimeout(null);
    $process->start();
    do {
        $animation->tick('Starting the dashboard');
        usleep(100*1000);
        $serverOutput = $process->getOutput() . $process->getErrorOutput();
        $hasStarted = (strpos($serverOutput, 'Development Server') !== false);
    } while ($process->isRunning() && !$hasStarted);
    $animation->clear();
    if (!$process->isRunning()) {
        $io->error([
            'The dashboard failed to start',
            $process->getErrorOutput(),
        ]);

        return 1;
    }
    $url = "http://$host:$port";
    $io->writeln("Dashboard started: <fg=green;options=bold,underscore>$url</>");
    OpenUrl::open($url);
    $process->wait(function ($type, $buffer) {
        if (Process::ERR === $type) {
            echo 'ERR > '.$buffer;
        } else {
            echo 'OUT > '.$buffer;
        }
    });

    return $process->getExitCode();
})->descriptions('Start the dashboard');

$app->command('layers region', function (string $region, SymfonyStyle $io) {
    $layers = json_decode(file_get_contents(__DIR__ . '/layers.json'), true);
    $io->title("Layers for the $region region");

    $array = [];
    foreach ($layers as $layer => $versions) {
        $version = $versions[$region];
        $array[] = [
            $layer,
            $version,
            "arn:aws:lambda:$region:416566615250:layer:$layer:$version",
        ];
    }
    $io->table([
        'Layer',
        'Version',
        'ARN',
    ], $array);

    return 0;
})->descriptions('Displays the versions of the Bref layers');

$app->run();
